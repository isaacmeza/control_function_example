<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
	inlineMath: [['$','$']],
	processEscapes: true
	}
});
</script>
<script type="text/javascript" async 
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
</script>
<h1><a href="#control-function" id="control-function">Control Function</a></h1>
<h3><a href="#isaac-m" id="isaac-m">Isaac M</a></h3>
<hr />
<p>In this note we study control function (CF) methods. We use data from a RCT in MCLC @sadka, to study the effect of statistical information ($x_j$) provided to dismissed workers <em>when the worker is present</em> ($t_j$)  on settlement rates ($y_j$).</p>
<p>The calculator arm ($x_j$) is random, but we might be concerned with the endogeneity of employee presence ($t_j$).  While this is fundamentally an external validity issue (since the calculator is random conditional on the plaintiff&rsquo;s presence), it is relevant for how we interpret the null treatment effect when the employee is not present. To address any concern with the endoegeneity of the plaintiff&rsquo;s presence, we use control function approaches. We use time of hearing ($w_j$) as instrument.</p>
<pre><code>. import delimited &quot;https://raw.githubusercontent.com/isaacmeza/control_function_example/main/DB/cf_pactor_sett.csv&quot;
&gt; , clear  case(preserve)
(encoding automatically selected: ISO-8859-1)
(19 vars, 1,732 obs)

</code></pre>
<p>To motivate the use of control function methods, we contrast it with the usual 2sls estimator. We cluster the errors at the level of randomization and use basic controls.</p>
<pre><code>. ivregress 2sls seconcilio calc d_anio* d_num* d_junta* phase (p_actor calc_x_pactor = i.time_hr##i.calc), vce(clus
&gt; ter cluster_v)   
note: 1.calc omitted because of collinearity.

Instrumental variables 2SLS regression            Number of obs   =      1,723
                                                  Wald chi2(16)   =     164.80
                                                  Prob &gt; chi2     =     0.0000
                                                  R-squared       =     0.0722
                                                  Root MSE        =     .34909

                             (Std. err. adjusted for 700 clusters in cluster_v)
-------------------------------------------------------------------------------
              |               Robust
   seconcilio | Coefficient  std. err.      z    P&gt;|z|     [95% conf. interval]
--------------+----------------------------------------------------------------
      p_actor |   .3764376   .3203994     1.17   0.240    -.2515337    1.004409
calc_x_pactor |   .1582707   .4313301     0.37   0.714    -.6871207    1.003662
         calc |   .0047817   .0828154     0.06   0.954    -.1575335    .1670969
     d_anioC2 |  -.0431707   .0353022    -1.22   0.221    -.1123618    .0260204
     d_anioC3 |  -.0781149   .0601744    -1.30   0.194    -.1960546    .0398248
     d_anioC4 |   -.027374    .044538    -0.61   0.539    -.1146669    .0599189
     d_anioC5 |  -.0537756   .0471267    -1.14   0.254    -.1461422     .038591
     d_anioC6 |  -.0073023   .0640302    -0.11   0.909    -.1327992    .1181947
     d_anioC7 |   .0155657   .0840653     0.19   0.853    -.1491993    .1803308
       d_num2 |    .012786   .0427567     0.30   0.765    -.0710155    .0965876
       d_num3 |  -.0249497   .0347275    -0.72   0.472    -.0930144     .043115
     d_junta2 |  -.0111277   .0446982    -0.25   0.803    -.0987345    .0764792
     d_junta3 |  -.0188805   .0351032    -0.54   0.591    -.0876814    .0499205
     d_junta4 |   .2024814   .0379855     5.33   0.000     .1280312    .2769315
     d_junta5 |  -.0636965   .0363869    -1.75   0.080    -.1350135    .0076205
        phase |   .0231708   .0544132     0.43   0.670     -.083477    .1298187
        _cons |   .0075994   .1011457     0.08   0.940    -.1906425    .2058412
-------------------------------------------------------------------------------
Instrumented: p_actor calc_x_pactor
 Instruments: calc d_anioC2 d_anioC3 d_anioC4 d_anioC5 d_anioC6 d_anioC7
              d_num2 d_num3 d_junta2 d_junta3 d_junta4 d_junta5 phase
              2.time_hr 3.time_hr 4.time_hr 5.time_hr 6.time_hr 7.time_hr
              8.time_hr 2.time_hr#1.calc 3.time_hr#1.calc 4.time_hr#1.calc
              5.time_hr#1.calc 6.time_hr#1.calc 7.time_hr#1.calc
              8.time_hr#1.calc

. 
</code></pre>
<p>We are interested in the coefficient of the interaction <strong>calc_x_pactor</strong>. We find an effect of      0.16, however we cannot reject the null of no significance (we have a std. error of      0.43). The advantage of CF methods is to achieve greater efficiency exploting the binary nature of the EEV, in this case &lsquo;presence of the employee&rsquo;.</p>
<h3><a href="#constrained-model-constant-coefficients" id="constrained-model-constant-coefficients">Constrained model - Constant Coefficients</a></h3>
<p>The model of interest is $$ y_j = x_j\beta +\delta t_j+\epsilon_j$$</p>
<p>where $t_j$ is a binary-treatment variable generated by an unobservable latent model: $$t_j = 1[w_j\gamma + u_j&gt;0]$$ and $\epsilon$, $u$ are bivariate normal with mean zero and covariance matrix</p>
<p>$$ \begin{bmatrix} \sigma^2 &amp; \rho\sigma \end{bmatrix}$$ $$ \begin{bmatrix}\rho\sigma &amp; 1 \end{bmatrix}$$</p>
<p>We also allow interactions between $x_j$ and the treatment $t_j$.</p>
<h2><a href="#two-step-cf" id="two-step-cf">Two-step CF</a></h2>
<p>For the two-step control function procedure, probit estimates of the (EEV) $$\Pr(T_j=1;|;w_j) = \Phi(w_j\gamma)$$ are obtained in the first stage. From these estimates we obtain &ldquo;generalized residuals&rdquo; $$r_j = t_j(\frac{\phi(w_j\hat{\gamma})}{\Phi(w_j\hat{\gamma})})+(1-t_j)(-\frac{\phi(w_j\hat{\gamma})}{1-\Phi(w_j\hat{\gamma})})$$</p>
<p>then $$\mathbb{E}[y_j;|;t_j,x_j,w_j]  = x_j\beta +\delta t_j+\rho\sigma r_j$$ $$\operatorname{Var}(y_j;|;t_j,x_j,w_j) = \sigma^2(1-\rho^2(r_j(r_j+w_j\hat\gamma)))$$</p>
<p>the two-step estimates of $\beta$ and $\delta$ are obtained by augmenting the regression with the generalized residuals. The t statistic on $r_j$, made robust to heteroskedasticity, is a valid test of the null that $t_j$ is exogenous.</p>
<h3><a href="#estimation" id="estimation">Estimation</a></h3>
<p>We &ldquo;manually&rdquo; implement the previous approach as follows:</p>
<p>1) Estimate first stage using probit</p>
<pre><code>. *Probit (FS)
. probit p_actor calc i.time_hr d_anio* d_num* d_junta* phase

Iteration 0:   log likelihood = -833.25244  
Iteration 1:   log likelihood = -798.71826  
Iteration 2:   log likelihood = -797.69333  
Iteration 3:   log likelihood =  -797.6822  
Iteration 4:   log likelihood =  -797.6822  

Probit regression                                       Number of obs =  1,732
                                                        LR chi2(21)   =  71.14
                                                        Prob &gt; chi2   = 0.0000
Log likelihood = -797.6822                              Pseudo R2     = 0.0427

------------------------------------------------------------------------------
     p_actor | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
        calc |   .1082908   .0774766     1.40   0.162    -.0435606    .2601422
             |
     time_hr |
          2  |  -.1331129   .1413429    -0.94   0.346      -.41014    .1439142
          3  |  -.3259341    .119239    -2.73   0.006    -.5596383     -.09223
          4  |  -.1567091   .1350585    -1.16   0.246    -.4214188    .1080006
          5  |  -.2240679   .1257006    -1.78   0.075    -.4704364    .0223007
          6  |  -.5026263   .1572906    -3.20   0.001    -.8109103   -.1943423
          7  |  -.1377779   .1272578    -1.08   0.279    -.3871986    .1116429
          8  |  -.0297373   .4711496    -0.06   0.950    -.9531735    .8936989
             |
    d_anioC2 |   .3072812   .6239511     0.49   0.622    -.9156404    1.530203
    d_anioC3 |   1.164786   .4732901     2.46   0.014     .2371544    2.092417
    d_anioC4 |   .7100118   .4648649     1.53   0.127    -.2011067     1.62113
    d_anioC5 |   1.037577   .4362145     2.38   0.017     .1826126    1.892542
    d_anioC6 |   1.360544   .4269148     3.19   0.001      .523806    2.197281
    d_anioC7 |   1.586553   .4387762     3.62   0.000     .7265675    2.446539
      d_num2 |  -.5973385   .2551905    -2.34   0.019    -1.097503   -.0971742
      d_num3 |  -.0188294     .17946    -0.10   0.916    -.3705646    .3329057
    d_junta2 |   .3134798   .1481717     2.12   0.034     .0230687     .603891
    d_junta3 |   .1552163   .1482518     1.05   0.295     -.135352    .4457845
    d_junta4 |   .0260552   .1469173     0.18   0.859    -.2618973    .3140077
    d_junta5 |   .2763537   .1503102     1.84   0.066    -.0182489    .5709563
       phase |   -.335944   .1700589    -1.98   0.048    -.6692533   -.0026347
       _cons |  -1.842998    .504927    -3.65   0.000    -2.832636   -.8533588
------------------------------------------------------------------------------

</code></pre>
<p>obtain generalized residual to form the augmented regression in the second stage</p>
<pre><code>. *Linear predictions
. cap drop xb

. predict xb, xb

. *Generalized residuals
. cap drop gen_resid_pr

. gen gen_resid_pr = cond(p_actor == 1, normalden(xb)/normal(xb), -normalden(xb)/(1-normal(xb)))  

</code></pre>
<p>2) Run the second stage. We use bootstrap to estimate standard errors, since estimation is done in two stages.</p>
<pre><code>. *Second stage
. reg seconcilio calc p_actor calc_x_pactor gen_resid_p d_anio* d_num* d_junta* phase , vce(bootstrap, cluster(clust
&gt; er_v) rep(1000) bca)
(running regress on estimation sample)

Jackknife replications (700)
----+--- 1 ---+--- 2 ---+--- 3 ---+--- 4 ---+--- 5 
..................................................    50
..................................................   100
..................................................   150
..................................................   200
..................................................   250
..................................................   300
..................................................   350
..................................................   400
..................................................   450
..................................................   500
..................................................   550
..................................................   600
..................................................   650
..................................................   700

Bootstrap replications (1,000)
----+--- 1 ---+--- 2 ---+--- 3 ---+--- 4 ---+--- 5 
..................................................    50
..................................................   100
..................................................   150
..................................................   200
..................................................   250
..................................................   300
..................................................   350
..................................................   400
..................................................   450
..................................................   500
..................................................   550
..................................................   600
..................................................   650
..................................................   700
..................................................   750
..................................................   800
..................................................   850
..................................................   900
..................................................   950
.................................................. 1,000

Linear regression                                       Number of obs =  1,723
                                                        Replications  =  1,000
                                                        Wald chi2(17) = 271.03
                                                        Prob &gt; chi2   = 0.0000
                                                        R-squared     = 0.1438
                                                        Adj R-squared = 0.1353
                                                        Root MSE      = 0.3371

                              (Replications based on 700 clusters in cluster_v)
-------------------------------------------------------------------------------
              |   Observed   Bootstrap                         Normal-based
   seconcilio | coefficient  std. err.      z    P&gt;|z|     [95% conf. interval]
--------------+----------------------------------------------------------------
         calc |   .0022582   .0172544     0.13   0.896    -.0315598    .0360762
      p_actor |   .6966963   .2119233     3.29   0.001     .2813344    1.112058
calc_x_pactor |   .1223531   .0530376     2.31   0.021     .0184014    .2263048
 gen_resid_pr |  -.3104685   .1137132    -2.73   0.006    -.5333422   -.0875948
     d_anioC2 |  -.0457858   .0255682    -1.79   0.073    -.0958986     .004327
     d_anioC3 |  -.1326319   .0492931    -2.69   0.007    -.2292446   -.0360192
     d_anioC4 |  -.0468025   .0401442    -1.17   0.244    -.1254838    .0318787
     d_anioC5 |  -.0949507   .0407189    -2.33   0.020    -.1747583   -.0151431
     d_anioC6 |  -.0736114     .05482    -1.34   0.179    -.1810567    .0338339
     d_anioC7 |  -.0742996   .0703521    -1.06   0.291    -.2121873     .063588
       d_num2 |   .0476116   .0415588     1.15   0.252    -.0338421    .1290654
       d_num3 |  -.0245896   .0327161    -0.75   0.452    -.0887121    .0395328
     d_junta2 |  -.0349334   .0416985    -0.84   0.402     -.116661    .0467942
     d_junta3 |  -.0273751   .0336521    -0.81   0.416     -.093332    .0385818
     d_junta4 |   .2027386   .0378757     5.35   0.000     .1285036    .2769736
     d_junta5 |  -.0851906   .0320855    -2.66   0.008     -.148077   -.0223042
        phase |   .0544593   .0504421     1.08   0.280    -.0444055    .1533241
        _cons |  -.0078127   .0793433    -0.10   0.922    -.1633227    .1476973
-------------------------------------------------------------------------------

</code></pre>
<p>As suggested by @Wooldridge, when the EEV $t_j$ interacts with $x_j$ there are other natural choices for IVs: Use the interactions $\Phi(w_j\hat\gamma)x_j$ where $\Phi(w_j\hat\gamma)$ are the predicted probabilities of $t_j$. This IV estimator has a theoretical advantage over the CF estimator, at least if one assumes the linear model with constant coefficients is the correct specification: The IV estimator is generally consistent even if the probit model is misspecified</p>
<h3><a href="#estimation" id="estimation">Estimation</a></h3>
<h3><a href="#general-potential-outcome-model-correlated-random-coefficient" id="general-potential-outcome-model-correlated-random-coefficient">General potential outcome model - Correlated Random Coefficient</a></h3>
<p>The setup of the previous section allows the endogenous explanatory variable or variables to appear linearly or nonlinearly and to interact with observed covariates. This may be sufficient for some applications, but one may also want to allow the effect of y2 to depend on unobs</p>
<p>ved fully. When one allows random coefficients to be correlated with some explanatory variables, such as amount of school or choice of school, one obtains a &ldquo;correlated random coefficient&rdquo; (CRC) model, a label adopted by Heckman and Vytlacil (1998) and discussed in the context of the return to schooling by Card (2001). In the treatment effects literature, CRC models allow for heterogeneous treatment effects combined with self-selection into treatment —provided that there are suitable instrumental variables for treatment as signment</p>
<p>The recent literature on instrumental variables (IV) features models in which agents sort into treatment status on the basis of gains from treatment as well as on baseline-pretreatment levels. Components of the gains known to the agents and acted on by them may not be known by the observing economist. Such models are called correlated random coefficient models.</p>
<p>etregress seconcilio altT i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase) twostep first</p>
<p>*CF *Probit - Interaction</p>
<p>eststo clear</p>
<p>gen esample = e(sample)</p>
<p>eststo : reg seconcilio altT p_actor   i.anioControl i.numActores i.junta i.phase gen_resid_p</p>
<p>eststo : reg seconcilio altT i.p_actor##c.gen_resid_p   i.anioControl i.numActores i.junta i.phase</p>
<p>eststo : reg seconcilio altT p_actor interactT  i.anioControl i.numActores i.junta i.phase gen_resid_p</p>
<p>*CRC</p>
<p>eststo : reg seconcilio altT i.p_actor##c.gen_resid_p interactT  i.anioControl i.numActores i.junta i.phase</p>
<p>etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase) twostep</p>
<p>etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase)  cfunction  poutcomes</p>
<p>etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase)    poutcomes</p>
<pre><code>etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase)  cfunction  
</code></pre>
<p>etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase)</p>
<p>reg p_actor  i.altT##i.time_hr i.anioControl i.numActores i.junta i.phase if esample cap drop p1 predict p1 reg interactT i.altT##i.time_hr i.anioControl i.numActores i.junta i.phase if esample cap drop p2 predict p2</p>
<p>reg seconcilio altT p1 p2 i.anioControl i.numActores i.junta i.phase if esample</p>
<p>ivregress 2sls seconcilio altT   i.anioControl i.numActores i.junta i.phase (p_actor  = i.time_hr), first</p>
<p>probit p_actor  i.altT time_hr2-time_hr8 d_anio* d_num* d_junta* phase cap drop p1 predict p1</p>
<p>reg seconcilio altT p1 d_anio* d_num* d_junta* phase</p>
<p>cap drop pint su altT gen pint = p1*(altT-`r(mean)&rsquo;) reg seconcilio altT p1 pint d_anio* d_num* d_junta* phase</p>
<p>ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase , model(direct-2sls) iv(time_hr2-time_hr8) hetero(altT)</p>
<p>ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase, model(probit-ols) iv(time_hr2-time_hr8) hetero(altT)</p>
<p>di   e(ate)<br />
di   e(atet) di  e(atent)</p>
<p>ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase, model(probit-2sls) iv(time_hr2-time_hr8) hetero(altT)</p>
<p>ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase, model(heckit) iv(time_hr2-time_hr8) hetero(altT)</p>
<p>ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase, model(heckit) iv(time_hr2-time_hr8) hetero(altT)</p>
<p>&laquo;/dd_do&raquo;</p>
<pre><code>
el mate 
$$\mathbb{E}[x-y]$$

pero es igual que $a-v$ sdfsdfdfg

y entonces se da que 
</code></pre>
