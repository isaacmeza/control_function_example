<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
	inlineMath: [['$','$']],
	processEscapes: true
	}
});
</script>
<script type="text/javascript" async 
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
</script>

# Control Function

### Isaac M
--------------------------------------------------------------------------------



In this note we study control function (CF) methods. We use data from a RCT in MCLC @sadka, to study the effect of statistical information ($x_j$) provided to dismissed workers *when the worker is present* ($t_j$)  on settlement rates ($y_j$).



The calculator arm ($x_j$) is random, but we might be concerned with the endogeneity of employee presence ($t_j$).  While this is fundamentally an external validity issue (since the calculator is random conditional on the plaintiff's presence), it is relevant for how we interpret the null treatment effect when the employee is not present. To address any concern with the endoegeneity of the plaintiff's presence, we use control function approaches. We use time of hearing ($w_j$) as instrument. 


~~~~
<<dd_do>>
import delimited "https://raw.githubusercontent.com/isaacmeza/control_function_example/main/DB/cf_pactor_sett.csv", clear  case(preserve)
<</dd_do>>
~~~~

To motivate the use of control function methods, we contrast it with the usual 2sls estimator. We cluster the errors at the level of randomization and use basic controls.

~~~~
<<dd_do>>
ivregress 2sls seconcilio calc d_anio* d_num* d_junta* phase (p_actor calc_x_pactor = i.time_hr##i.calc), vce(cluster cluster_v)   

<</dd_do>>
~~~~


We are interested in the coefficient of the interaction **calc_x_pactor**. We find an effect of <<dd_display: %9.3f _b[calc_x_pactor]>>, however we cannot reject the null of no significance (we have a std. error of <<dd_display: %9.2f _se[calc_x_pactor]>>). The advantage of CF methods is to achieve greater efficiency exploting the binary nature of the EEV, in this case 'presence of the employee'.


### Constrained model - Constant Coefficients

The model of interest is
$$ y_j = x_j\beta +\delta t_j+\epsilon_j$$

where $t_j$ is a binary-treatment variable generated by an unobservable latent model:
$$t_j = 1[w_j\gamma + u_j>0]$$
and $\epsilon$, $u$ are bivariate normal with mean zero and covariance matrix

$$ \begin{bmatrix} \sigma^2 
& \rho\sigma 
\end{bmatrix}$$ 
$$ \begin{bmatrix}\rho\sigma & 1 
\end{bmatrix}$$ 


We also allow interactions between $x_j$ and the treatment $t_j$. 





## Two-step CF

For the two-step control function procedure, probit estimates of the (EEV) 
$$\Pr(T_j=1\;|\;w_j) = \Phi(w_j\gamma)$$
are obtained in the first stage.
From these estimates we obtain "generalized residuals" 
$$r_j = t_j(\frac{\phi(w_j\hat{\gamma})}{\Phi(w_j\hat{\gamma})})+(1-t_j)(-\frac{\phi(w_j\hat{\gamma})}{1-\Phi(w_j\hat{\gamma})})$$

then
$$\mathbb{E}[y_j\;|\;t_j,x_j,w_j]  = x_j\beta +\delta t_j+\rho\sigma r_j$$
$$\operatorname{Var}(y_j\;|\;t_j,x_j,w_j) = \sigma^2(1-\rho^2(r_j(r_j+w_j\hat\gamma)))$$

the two-step estimates of $\beta$ and $\delta$ are obtained by augmenting the regression with the generalized residuals. The t statistic on $r_j$, made robust to heteroskedasticity, is a valid test of the null that $t_j$ is exogenous.

### Estimation

We "manually" implement the previous approach as follows:

1) Estimate first stage using probit
~~~~
<<dd_do>>
*Probit (FS)
probit p_actor calc i.time_hr d_anio* d_num* d_junta* phase
<</dd_do>>
~~~~

 obtain generalized residual to form the augmented regression in the second stage
~~~~
<<dd_do>>
*Linear predictions
cap drop xb
predict xb, xb
*Generalized residuals
cap drop gen_resid_pr
gen gen_resid_pr = cond(p_actor == 1, normalden(xb)/normal(xb), -normalden(xb)/(1-normal(xb)))	
<</dd_do>>
~~~~

2) Run the second stage. We use bootstrap to estimate standard errors, since estimation is done in two stages. 
~~~~
<<dd_do>>
*Second stage
reg seconcilio calc p_actor calc_x_pactor gen_resid_p d_anio* d_num* d_junta* phase , vce(bootstrap, cluster(cluster_v) rep(100) bca)
<</dd_do>>
~~~~

Note that by exploting the binary nature of the endogenous variable, we achieve more efficiency. The coefficient of the interaction is <<dd_display: %9.3f _b[calc_x_pactor]>>, which is smaller than the 2sls IV estimate, and we get significance at the <<dd_display: %9.3f 200*ttail(e(N)-e(df_m), abs(_b[calc_x_pactor]/_se[calc_x_pactor]))>>% level.

As suggested by @Wooldridge, when the EEV $t_j$ interacts with $x_j$ there are other natural choices for IVs: Use the interactions $\Phi(w_j\hat\gamma)x_j$ where $\Phi(w_j\hat\gamma)$ are the predicted probabilities of $t_j$. This IV estimator has a theoretical advantage over the CF estimator, at least if one assumes the linear model with constant coefficients is the correct specification: The IV estimator is generally consistent even if the probit model is misspecified

### Estimation

### General potential outcome model - Correlated Random Coefficient

 The setup of the previous section allows the endogenous explanatory variable or variables to appear linearly or nonlinearly and to interact with observed covariates. This may be sufficient for some applications, but one may also want to allow the effect of y2 to depend on unobs

 ved fully. When one allows random coefficients to be correlated with some explanatory variables, such as amount of school or choice of school, one obtains a "correlated random coefficient" (CRC) model, a label adopted by Heckman and Vytlacil (1998) and discussed in the context of the return to schooling by Card (2001). In the treatment effects literature, CRC models allow for heterogeneous treatment effects combined with self-selection into treatment â€”provided that there are suitable instrumental variables for treatment as signment


 The recent literature on instrumental variables (IV) features models in which agents sort into treatment status on the basis of gains from treatment as well as on baseline-pretreatment levels. Components of the gains known to the agents and acted on by them may not be known by the observing economist. Such models are called correlated random coefficient models.
 
 
 




   etregress seconcilio altT i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase) twostep first
   

*CF
*Probit - Interaction

eststo clear




gen esample = e(sample)

eststo : reg seconcilio altT p_actor   i.anioControl i.numActores i.junta i.phase gen_resid_p  


eststo : reg seconcilio altT i.p_actor##c.gen_resid_p   i.anioControl i.numActores i.junta i.phase   



eststo : reg seconcilio altT p_actor interactT  i.anioControl i.numActores i.junta i.phase gen_resid_p 



*CRC

eststo : reg seconcilio altT i.p_actor##c.gen_resid_p interactT  i.anioControl i.numActores i.junta i.phase 




   



   etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase) twostep  

   etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase)  cfunction  poutcomes
   
   etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase)    poutcomes
   
    etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase)  cfunction  
   
   etregress seconcilio i.altT##i.p_actor i.anioControl i.numActores i.junta i.phase , treat(p_actor = i.time_hr altT i.anioControl i.numActores i.junta i.phase)      
   
   
   
   
reg p_actor  i.altT##i.time_hr i.anioControl i.numActores i.junta i.phase if esample
cap drop p1
predict p1
reg interactT i.altT##i.time_hr i.anioControl i.numActores i.junta i.phase if esample
cap drop p2
predict p2

reg seconcilio altT p1 p2 i.anioControl i.numActores i.junta i.phase if esample


ivregress 2sls seconcilio altT   i.anioControl i.numActores i.junta i.phase (p_actor  = i.time_hr), first



probit p_actor  i.altT time_hr2-time_hr8 d_anio* d_num* d_junta* phase
cap drop p1
predict p1

reg seconcilio altT p1 d_anio* d_num* d_junta* phase


cap drop pint
su altT 
gen pint = p1*(altT-`r(mean)')
reg seconcilio altT p1 pint d_anio* d_num* d_junta* phase

 
ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase , model(direct-2sls) iv(time_hr2-time_hr8) hetero(altT) 
   
ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase, model(probit-ols) iv(time_hr2-time_hr8) hetero(altT) 
   
di   e(ate)   
di   e(atet)
di  e(atent)


ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase, model(probit-2sls) iv(time_hr2-time_hr8) hetero(altT) 


ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase, model(heckit) iv(time_hr2-time_hr8) hetero(altT) 

ivtreatreg seconcilio p_actor altT d_anio* d_num* d_junta* phase, model(heckit) iv(time_hr2-time_hr8) hetero(altT) 


<</dd_do>>
~~~~

el mate 
$$\mathbb{E}[x-y]$$

pero es igual que $a-v$ sdfsdfdfg

y entonces se da que 
